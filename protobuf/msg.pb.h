// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mxw {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class login;
class loginVisitor;
class relogin;
class loginRet;
class createRole;
class createRoleRet;
class playerList;
class playerList_player;
class selectPlayer;
class playerBaseData;

enum loginRet_ELoginErr {
  loginRet_ELoginErr_ELE_Success = 1,
  loginRet_ELoginErr_ELE_Failed = 2,
  loginRet_ELoginErr_ELE_CreateRole = 3
};
bool loginRet_ELoginErr_IsValid(int value);
const loginRet_ELoginErr loginRet_ELoginErr_ELoginErr_MIN = loginRet_ELoginErr_ELE_Success;
const loginRet_ELoginErr loginRet_ELoginErr_ELoginErr_MAX = loginRet_ELoginErr_ELE_CreateRole;
const int loginRet_ELoginErr_ELoginErr_ARRAYSIZE = loginRet_ELoginErr_ELoginErr_MAX + 1;

const ::google::protobuf::EnumDescriptor* loginRet_ELoginErr_descriptor();
inline const ::std::string& loginRet_ELoginErr_Name(loginRet_ELoginErr value) {
  return ::google::protobuf::internal::NameOfEnum(
    loginRet_ELoginErr_descriptor(), value);
}
inline bool loginRet_ELoginErr_Parse(
    const ::std::string& name, loginRet_ELoginErr* value) {
  return ::google::protobuf::internal::ParseNamedEnum<loginRet_ELoginErr>(
    loginRet_ELoginErr_descriptor(), name, value);
}
enum s2c_PROTOCOL {
  s2c_begin = 0,
  s2c_loginRet = 1,
  s2c_playerList = 2,
  s2c_createPlayerRet = 3,
  s2c_playerBaseData = 4,
  s2c_serverInfo = 5,
  s2c_end = 255
};
bool s2c_PROTOCOL_IsValid(int value);
const s2c_PROTOCOL s2c_PROTOCOL_MIN = s2c_begin;
const s2c_PROTOCOL s2c_PROTOCOL_MAX = s2c_end;
const int s2c_PROTOCOL_ARRAYSIZE = s2c_PROTOCOL_MAX + 1;

const ::google::protobuf::EnumDescriptor* s2c_PROTOCOL_descriptor();
inline const ::std::string& s2c_PROTOCOL_Name(s2c_PROTOCOL value) {
  return ::google::protobuf::internal::NameOfEnum(
    s2c_PROTOCOL_descriptor(), value);
}
inline bool s2c_PROTOCOL_Parse(
    const ::std::string& name, s2c_PROTOCOL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<s2c_PROTOCOL>(
    s2c_PROTOCOL_descriptor(), name, value);
}
enum c2s_PROTOCOL {
  c2s_begin = 0,
  c2s_login = 1,
  c2s_login_visitor = 2,
  c2s_relogin = 3,
  c2s_createPlayer = 4,
  c2s_end = 255
};
bool c2s_PROTOCOL_IsValid(int value);
const c2s_PROTOCOL c2s_PROTOCOL_MIN = c2s_begin;
const c2s_PROTOCOL c2s_PROTOCOL_MAX = c2s_end;
const int c2s_PROTOCOL_ARRAYSIZE = c2s_PROTOCOL_MAX + 1;

const ::google::protobuf::EnumDescriptor* c2s_PROTOCOL_descriptor();
inline const ::std::string& c2s_PROTOCOL_Name(c2s_PROTOCOL value) {
  return ::google::protobuf::internal::NameOfEnum(
    c2s_PROTOCOL_descriptor(), value);
}
inline bool c2s_PROTOCOL_Parse(
    const ::std::string& name, c2s_PROTOCOL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<c2s_PROTOCOL>(
    c2s_PROTOCOL_descriptor(), name, value);
}
enum EClient_OS_Type {
  ECOT_IOS = 0,
  ECOT_ANDROID = 1
};
bool EClient_OS_Type_IsValid(int value);
const EClient_OS_Type EClient_OS_Type_MIN = ECOT_IOS;
const EClient_OS_Type EClient_OS_Type_MAX = ECOT_ANDROID;
const int EClient_OS_Type_ARRAYSIZE = EClient_OS_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* EClient_OS_Type_descriptor();
inline const ::std::string& EClient_OS_Type_Name(EClient_OS_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    EClient_OS_Type_descriptor(), value);
}
inline bool EClient_OS_Type_Parse(
    const ::std::string& name, EClient_OS_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EClient_OS_Type>(
    EClient_OS_Type_descriptor(), name, value);
}
// ===================================================================

class login : public ::google::protobuf::Message {
 public:
  login();
  virtual ~login();

  login(const login& from);

  inline login& operator=(const login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login& default_instance();

  void Swap(login* other);

  // implements Message ----------------------------------------------

  login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login& from);
  void MergeFrom(const login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uiAccountCRC = 1;
  inline bool has_uiaccountcrc() const;
  inline void clear_uiaccountcrc();
  static const int kUiAccountCRCFieldNumber = 1;
  inline ::google::protobuf::uint32 uiaccountcrc() const;
  inline void set_uiaccountcrc(::google::protobuf::uint32 value);

  // optional string szIMEI = 2;
  inline bool has_szimei() const;
  inline void clear_szimei();
  static const int kSzIMEIFieldNumber = 2;
  inline const ::std::string& szimei() const;
  inline void set_szimei(const ::std::string& value);
  inline void set_szimei(const char* value);
  inline void set_szimei(const char* value, size_t size);
  inline ::std::string* mutable_szimei();
  inline ::std::string* release_szimei();
  inline void set_allocated_szimei(::std::string* szimei);

  // required .mxw.EClient_OS_Type eClientOSType = 3;
  inline bool has_eclientostype() const;
  inline void clear_eclientostype();
  static const int kEClientOSTypeFieldNumber = 3;
  inline ::mxw::EClient_OS_Type eclientostype() const;
  inline void set_eclientostype(::mxw::EClient_OS_Type value);

  // required uint32 uiServerID = 4;
  inline bool has_uiserverid() const;
  inline void clear_uiserverid();
  static const int kUiServerIDFieldNumber = 4;
  inline ::google::protobuf::uint32 uiserverid() const;
  inline void set_uiserverid(::google::protobuf::uint32 value);

  // required uint32 uiVersion = 5;
  inline bool has_uiversion() const;
  inline void clear_uiversion();
  static const int kUiVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 uiversion() const;
  inline void set_uiversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mxw.login)
 private:
  inline void set_has_uiaccountcrc();
  inline void clear_has_uiaccountcrc();
  inline void set_has_szimei();
  inline void clear_has_szimei();
  inline void set_has_eclientostype();
  inline void clear_has_eclientostype();
  inline void set_has_uiserverid();
  inline void clear_has_uiserverid();
  inline void set_has_uiversion();
  inline void clear_has_uiversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szimei_;
  ::google::protobuf::uint32 uiaccountcrc_;
  int eclientostype_;
  ::google::protobuf::uint32 uiserverid_;
  ::google::protobuf::uint32 uiversion_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static login* default_instance_;
};
// -------------------------------------------------------------------

class loginVisitor : public ::google::protobuf::Message {
 public:
  loginVisitor();
  virtual ~loginVisitor();

  loginVisitor(const loginVisitor& from);

  inline loginVisitor& operator=(const loginVisitor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginVisitor& default_instance();

  void Swap(loginVisitor* other);

  // implements Message ----------------------------------------------

  loginVisitor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginVisitor& from);
  void MergeFrom(const loginVisitor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szIMEI = 1;
  inline bool has_szimei() const;
  inline void clear_szimei();
  static const int kSzIMEIFieldNumber = 1;
  inline const ::std::string& szimei() const;
  inline void set_szimei(const ::std::string& value);
  inline void set_szimei(const char* value);
  inline void set_szimei(const char* value, size_t size);
  inline ::std::string* mutable_szimei();
  inline ::std::string* release_szimei();
  inline void set_allocated_szimei(::std::string* szimei);

  // required .mxw.EClient_OS_Type eClientOSType = 2 [default = ECOT_IOS];
  inline bool has_eclientostype() const;
  inline void clear_eclientostype();
  static const int kEClientOSTypeFieldNumber = 2;
  inline ::mxw::EClient_OS_Type eclientostype() const;
  inline void set_eclientostype(::mxw::EClient_OS_Type value);

  // required uint32 uiServerID = 3;
  inline bool has_uiserverid() const;
  inline void clear_uiserverid();
  static const int kUiServerIDFieldNumber = 3;
  inline ::google::protobuf::uint32 uiserverid() const;
  inline void set_uiserverid(::google::protobuf::uint32 value);

  // required uint32 uiVersion = 4;
  inline bool has_uiversion() const;
  inline void clear_uiversion();
  static const int kUiVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 uiversion() const;
  inline void set_uiversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mxw.loginVisitor)
 private:
  inline void set_has_szimei();
  inline void clear_has_szimei();
  inline void set_has_eclientostype();
  inline void clear_has_eclientostype();
  inline void set_has_uiserverid();
  inline void clear_has_uiserverid();
  inline void set_has_uiversion();
  inline void clear_has_uiversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szimei_;
  int eclientostype_;
  ::google::protobuf::uint32 uiserverid_;
  ::google::protobuf::uint32 uiversion_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginVisitor* default_instance_;
};
// -------------------------------------------------------------------

class relogin : public ::google::protobuf::Message {
 public:
  relogin();
  virtual ~relogin();

  relogin(const relogin& from);

  inline relogin& operator=(const relogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const relogin& default_instance();

  void Swap(relogin* other);

  // implements Message ----------------------------------------------

  relogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const relogin& from);
  void MergeFrom(const relogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uiAccountCRC = 1;
  inline bool has_uiaccountcrc() const;
  inline void clear_uiaccountcrc();
  static const int kUiAccountCRCFieldNumber = 1;
  inline ::google::protobuf::int32 uiaccountcrc() const;
  inline void set_uiaccountcrc(::google::protobuf::int32 value);

  // optional string szIMEI = 2;
  inline bool has_szimei() const;
  inline void clear_szimei();
  static const int kSzIMEIFieldNumber = 2;
  inline const ::std::string& szimei() const;
  inline void set_szimei(const ::std::string& value);
  inline void set_szimei(const char* value);
  inline void set_szimei(const char* value, size_t size);
  inline ::std::string* mutable_szimei();
  inline ::std::string* release_szimei();
  inline void set_allocated_szimei(::std::string* szimei);

  // required .mxw.EClient_OS_Type eClientOSType = 3;
  inline bool has_eclientostype() const;
  inline void clear_eclientostype();
  static const int kEClientOSTypeFieldNumber = 3;
  inline ::mxw::EClient_OS_Type eclientostype() const;
  inline void set_eclientostype(::mxw::EClient_OS_Type value);

  // required uint32 uiServerID = 4;
  inline bool has_uiserverid() const;
  inline void clear_uiserverid();
  static const int kUiServerIDFieldNumber = 4;
  inline ::google::protobuf::uint32 uiserverid() const;
  inline void set_uiserverid(::google::protobuf::uint32 value);

  // required uint32 uiVersion = 5;
  inline bool has_uiversion() const;
  inline void clear_uiversion();
  static const int kUiVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 uiversion() const;
  inline void set_uiversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mxw.relogin)
 private:
  inline void set_has_uiaccountcrc();
  inline void clear_has_uiaccountcrc();
  inline void set_has_szimei();
  inline void clear_has_szimei();
  inline void set_has_eclientostype();
  inline void clear_has_eclientostype();
  inline void set_has_uiserverid();
  inline void clear_has_uiserverid();
  inline void set_has_uiversion();
  inline void clear_has_uiversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szimei_;
  ::google::protobuf::int32 uiaccountcrc_;
  int eclientostype_;
  ::google::protobuf::uint32 uiserverid_;
  ::google::protobuf::uint32 uiversion_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static relogin* default_instance_;
};
// -------------------------------------------------------------------

class loginRet : public ::google::protobuf::Message {
 public:
  loginRet();
  virtual ~loginRet();

  loginRet(const loginRet& from);

  inline loginRet& operator=(const loginRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const loginRet& default_instance();

  void Swap(loginRet* other);

  // implements Message ----------------------------------------------

  loginRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const loginRet& from);
  void MergeFrom(const loginRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef loginRet_ELoginErr ELoginErr;
  static const ELoginErr ELE_Success = loginRet_ELoginErr_ELE_Success;
  static const ELoginErr ELE_Failed = loginRet_ELoginErr_ELE_Failed;
  static const ELoginErr ELE_CreateRole = loginRet_ELoginErr_ELE_CreateRole;
  static inline bool ELoginErr_IsValid(int value) {
    return loginRet_ELoginErr_IsValid(value);
  }
  static const ELoginErr ELoginErr_MIN =
    loginRet_ELoginErr_ELoginErr_MIN;
  static const ELoginErr ELoginErr_MAX =
    loginRet_ELoginErr_ELoginErr_MAX;
  static const int ELoginErr_ARRAYSIZE =
    loginRet_ELoginErr_ELoginErr_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ELoginErr_descriptor() {
    return loginRet_ELoginErr_descriptor();
  }
  static inline const ::std::string& ELoginErr_Name(ELoginErr value) {
    return loginRet_ELoginErr_Name(value);
  }
  static inline bool ELoginErr_Parse(const ::std::string& name,
      ELoginErr* value) {
    return loginRet_ELoginErr_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mxw.loginRet.ELoginErr nCode = 1;
  inline bool has_ncode() const;
  inline void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  inline ::mxw::loginRet_ELoginErr ncode() const;
  inline void set_ncode(::mxw::loginRet_ELoginErr value);

  // required int32 nToken = 2;
  inline bool has_ntoken() const;
  inline void clear_ntoken();
  static const int kNTokenFieldNumber = 2;
  inline ::google::protobuf::int32 ntoken() const;
  inline void set_ntoken(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mxw.loginRet)
 private:
  inline void set_has_ncode();
  inline void clear_has_ncode();
  inline void set_has_ntoken();
  inline void clear_has_ntoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int ncode_;
  ::google::protobuf::int32 ntoken_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static loginRet* default_instance_;
};
// -------------------------------------------------------------------

class createRole : public ::google::protobuf::Message {
 public:
  createRole();
  virtual ~createRole();

  createRole(const createRole& from);

  inline createRole& operator=(const createRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const createRole& default_instance();

  void Swap(createRole* other);

  // implements Message ----------------------------------------------

  createRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const createRole& from);
  void MergeFrom(const createRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szPlayerName = 1;
  inline bool has_szplayername() const;
  inline void clear_szplayername();
  static const int kSzPlayerNameFieldNumber = 1;
  inline const ::std::string& szplayername() const;
  inline void set_szplayername(const ::std::string& value);
  inline void set_szplayername(const char* value);
  inline void set_szplayername(const char* value, size_t size);
  inline ::std::string* mutable_szplayername();
  inline ::std::string* release_szplayername();
  inline void set_allocated_szplayername(::std::string* szplayername);

  // required int32 nSex = 2;
  inline bool has_nsex() const;
  inline void clear_nsex();
  static const int kNSexFieldNumber = 2;
  inline ::google::protobuf::int32 nsex() const;
  inline void set_nsex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mxw.createRole)
 private:
  inline void set_has_szplayername();
  inline void clear_has_szplayername();
  inline void set_has_nsex();
  inline void clear_has_nsex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szplayername_;
  ::google::protobuf::int32 nsex_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static createRole* default_instance_;
};
// -------------------------------------------------------------------

class createRoleRet : public ::google::protobuf::Message {
 public:
  createRoleRet();
  virtual ~createRoleRet();

  createRoleRet(const createRoleRet& from);

  inline createRoleRet& operator=(const createRoleRet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const createRoleRet& default_instance();

  void Swap(createRoleRet* other);

  // implements Message ----------------------------------------------

  createRoleRet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const createRoleRet& from);
  void MergeFrom(const createRoleRet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nCode = 1;
  inline bool has_ncode() const;
  inline void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  inline ::google::protobuf::int32 ncode() const;
  inline void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mxw.createRoleRet)
 private:
  inline void set_has_ncode();
  inline void clear_has_ncode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ncode_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static createRoleRet* default_instance_;
};
// -------------------------------------------------------------------

class playerList_player : public ::google::protobuf::Message {
 public:
  playerList_player();
  virtual ~playerList_player();

  playerList_player(const playerList_player& from);

  inline playerList_player& operator=(const playerList_player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const playerList_player& default_instance();

  void Swap(playerList_player* other);

  // implements Message ----------------------------------------------

  playerList_player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerList_player& from);
  void MergeFrom(const playerList_player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 2;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 2;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // @@protoc_insertion_point(class_scope:mxw.playerList.player)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szname_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static playerList_player* default_instance_;
};
// -------------------------------------------------------------------

class playerList : public ::google::protobuf::Message {
 public:
  playerList();
  virtual ~playerList();

  playerList(const playerList& from);

  inline playerList& operator=(const playerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const playerList& default_instance();

  void Swap(playerList* other);

  // implements Message ----------------------------------------------

  playerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerList& from);
  void MergeFrom(const playerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef playerList_player player;

  // accessors -------------------------------------------------------

  // required int32 nCount = 1;
  inline bool has_ncount() const;
  inline void clear_ncount();
  static const int kNCountFieldNumber = 1;
  inline ::google::protobuf::int32 ncount() const;
  inline void set_ncount(::google::protobuf::int32 value);

  // repeated .mxw.playerList.player players = 2;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 2;
  inline const ::mxw::playerList_player& players(int index) const;
  inline ::mxw::playerList_player* mutable_players(int index);
  inline ::mxw::playerList_player* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::mxw::playerList_player >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::mxw::playerList_player >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:mxw.playerList)
 private:
  inline void set_has_ncount();
  inline void clear_has_ncount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mxw::playerList_player > players_;
  ::google::protobuf::int32 ncount_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static playerList* default_instance_;
};
// -------------------------------------------------------------------

class selectPlayer : public ::google::protobuf::Message {
 public:
  selectPlayer();
  virtual ~selectPlayer();

  selectPlayer(const selectPlayer& from);

  inline selectPlayer& operator=(const selectPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const selectPlayer& default_instance();

  void Swap(selectPlayer* other);

  // implements Message ----------------------------------------------

  selectPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const selectPlayer& from);
  void MergeFrom(const selectPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // @@protoc_insertion_point(class_scope:mxw.selectPlayer)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szname_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static selectPlayer* default_instance_;
};
// -------------------------------------------------------------------

class playerBaseData : public ::google::protobuf::Message {
 public:
  playerBaseData();
  virtual ~playerBaseData();

  playerBaseData(const playerBaseData& from);

  inline playerBaseData& operator=(const playerBaseData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const playerBaseData& default_instance();

  void Swap(playerBaseData* other);

  // implements Message ----------------------------------------------

  playerBaseData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerBaseData& from);
  void MergeFrom(const playerBaseData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nIdx = 1;
  inline bool has_nidx() const;
  inline void clear_nidx();
  static const int kNIdxFieldNumber = 1;
  inline ::google::protobuf::int32 nidx() const;
  inline void set_nidx(::google::protobuf::int32 value);

  // required string szName = 2;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 2;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  inline void set_allocated_szname(::std::string* szname);

  // @@protoc_insertion_point(class_scope:mxw.playerBaseData)
 private:
  inline void set_has_nidx();
  inline void clear_has_nidx();
  inline void set_has_szname();
  inline void clear_has_szname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* szname_;
  ::google::protobuf::int32 nidx_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static playerBaseData* default_instance_;
};
// ===================================================================


// ===================================================================

// login

// required uint32 uiAccountCRC = 1;
inline bool login::has_uiaccountcrc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login::set_has_uiaccountcrc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login::clear_has_uiaccountcrc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login::clear_uiaccountcrc() {
  uiaccountcrc_ = 0u;
  clear_has_uiaccountcrc();
}
inline ::google::protobuf::uint32 login::uiaccountcrc() const {
  // @@protoc_insertion_point(field_get:mxw.login.uiAccountCRC)
  return uiaccountcrc_;
}
inline void login::set_uiaccountcrc(::google::protobuf::uint32 value) {
  set_has_uiaccountcrc();
  uiaccountcrc_ = value;
  // @@protoc_insertion_point(field_set:mxw.login.uiAccountCRC)
}

// optional string szIMEI = 2;
inline bool login::has_szimei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login::set_has_szimei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login::clear_has_szimei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login::clear_szimei() {
  if (szimei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_->clear();
  }
  clear_has_szimei();
}
inline const ::std::string& login::szimei() const {
  // @@protoc_insertion_point(field_get:mxw.login.szIMEI)
  return *szimei_;
}
inline void login::set_szimei(const ::std::string& value) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.login.szIMEI)
}
inline void login::set_szimei(const char* value) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.login.szIMEI)
}
inline void login::set_szimei(const char* value, size_t size) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.login.szIMEI)
}
inline ::std::string* login::mutable_szimei() {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.login.szIMEI)
  return szimei_;
}
inline ::std::string* login::release_szimei() {
  clear_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szimei_;
    szimei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_szimei(::std::string* szimei) {
  if (szimei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szimei_;
  }
  if (szimei) {
    set_has_szimei();
    szimei_ = szimei;
  } else {
    clear_has_szimei();
    szimei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.login.szIMEI)
}

// required .mxw.EClient_OS_Type eClientOSType = 3;
inline bool login::has_eclientostype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login::set_has_eclientostype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login::clear_has_eclientostype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login::clear_eclientostype() {
  eclientostype_ = 0;
  clear_has_eclientostype();
}
inline ::mxw::EClient_OS_Type login::eclientostype() const {
  // @@protoc_insertion_point(field_get:mxw.login.eClientOSType)
  return static_cast< ::mxw::EClient_OS_Type >(eclientostype_);
}
inline void login::set_eclientostype(::mxw::EClient_OS_Type value) {
  assert(::mxw::EClient_OS_Type_IsValid(value));
  set_has_eclientostype();
  eclientostype_ = value;
  // @@protoc_insertion_point(field_set:mxw.login.eClientOSType)
}

// required uint32 uiServerID = 4;
inline bool login::has_uiserverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void login::set_has_uiserverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void login::clear_has_uiserverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void login::clear_uiserverid() {
  uiserverid_ = 0u;
  clear_has_uiserverid();
}
inline ::google::protobuf::uint32 login::uiserverid() const {
  // @@protoc_insertion_point(field_get:mxw.login.uiServerID)
  return uiserverid_;
}
inline void login::set_uiserverid(::google::protobuf::uint32 value) {
  set_has_uiserverid();
  uiserverid_ = value;
  // @@protoc_insertion_point(field_set:mxw.login.uiServerID)
}

// required uint32 uiVersion = 5;
inline bool login::has_uiversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void login::set_has_uiversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void login::clear_has_uiversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void login::clear_uiversion() {
  uiversion_ = 0u;
  clear_has_uiversion();
}
inline ::google::protobuf::uint32 login::uiversion() const {
  // @@protoc_insertion_point(field_get:mxw.login.uiVersion)
  return uiversion_;
}
inline void login::set_uiversion(::google::protobuf::uint32 value) {
  set_has_uiversion();
  uiversion_ = value;
  // @@protoc_insertion_point(field_set:mxw.login.uiVersion)
}

// -------------------------------------------------------------------

// loginVisitor

// required string szIMEI = 1;
inline bool loginVisitor::has_szimei() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginVisitor::set_has_szimei() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginVisitor::clear_has_szimei() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginVisitor::clear_szimei() {
  if (szimei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_->clear();
  }
  clear_has_szimei();
}
inline const ::std::string& loginVisitor::szimei() const {
  // @@protoc_insertion_point(field_get:mxw.loginVisitor.szIMEI)
  return *szimei_;
}
inline void loginVisitor::set_szimei(const ::std::string& value) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.loginVisitor.szIMEI)
}
inline void loginVisitor::set_szimei(const char* value) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.loginVisitor.szIMEI)
}
inline void loginVisitor::set_szimei(const char* value, size_t size) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.loginVisitor.szIMEI)
}
inline ::std::string* loginVisitor::mutable_szimei() {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.loginVisitor.szIMEI)
  return szimei_;
}
inline ::std::string* loginVisitor::release_szimei() {
  clear_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szimei_;
    szimei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void loginVisitor::set_allocated_szimei(::std::string* szimei) {
  if (szimei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szimei_;
  }
  if (szimei) {
    set_has_szimei();
    szimei_ = szimei;
  } else {
    clear_has_szimei();
    szimei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.loginVisitor.szIMEI)
}

// required .mxw.EClient_OS_Type eClientOSType = 2 [default = ECOT_IOS];
inline bool loginVisitor::has_eclientostype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginVisitor::set_has_eclientostype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginVisitor::clear_has_eclientostype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginVisitor::clear_eclientostype() {
  eclientostype_ = 0;
  clear_has_eclientostype();
}
inline ::mxw::EClient_OS_Type loginVisitor::eclientostype() const {
  // @@protoc_insertion_point(field_get:mxw.loginVisitor.eClientOSType)
  return static_cast< ::mxw::EClient_OS_Type >(eclientostype_);
}
inline void loginVisitor::set_eclientostype(::mxw::EClient_OS_Type value) {
  assert(::mxw::EClient_OS_Type_IsValid(value));
  set_has_eclientostype();
  eclientostype_ = value;
  // @@protoc_insertion_point(field_set:mxw.loginVisitor.eClientOSType)
}

// required uint32 uiServerID = 3;
inline bool loginVisitor::has_uiserverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void loginVisitor::set_has_uiserverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void loginVisitor::clear_has_uiserverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void loginVisitor::clear_uiserverid() {
  uiserverid_ = 0u;
  clear_has_uiserverid();
}
inline ::google::protobuf::uint32 loginVisitor::uiserverid() const {
  // @@protoc_insertion_point(field_get:mxw.loginVisitor.uiServerID)
  return uiserverid_;
}
inline void loginVisitor::set_uiserverid(::google::protobuf::uint32 value) {
  set_has_uiserverid();
  uiserverid_ = value;
  // @@protoc_insertion_point(field_set:mxw.loginVisitor.uiServerID)
}

// required uint32 uiVersion = 4;
inline bool loginVisitor::has_uiversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void loginVisitor::set_has_uiversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void loginVisitor::clear_has_uiversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void loginVisitor::clear_uiversion() {
  uiversion_ = 0u;
  clear_has_uiversion();
}
inline ::google::protobuf::uint32 loginVisitor::uiversion() const {
  // @@protoc_insertion_point(field_get:mxw.loginVisitor.uiVersion)
  return uiversion_;
}
inline void loginVisitor::set_uiversion(::google::protobuf::uint32 value) {
  set_has_uiversion();
  uiversion_ = value;
  // @@protoc_insertion_point(field_set:mxw.loginVisitor.uiVersion)
}

// -------------------------------------------------------------------

// relogin

// required int32 uiAccountCRC = 1;
inline bool relogin::has_uiaccountcrc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void relogin::set_has_uiaccountcrc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void relogin::clear_has_uiaccountcrc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void relogin::clear_uiaccountcrc() {
  uiaccountcrc_ = 0;
  clear_has_uiaccountcrc();
}
inline ::google::protobuf::int32 relogin::uiaccountcrc() const {
  // @@protoc_insertion_point(field_get:mxw.relogin.uiAccountCRC)
  return uiaccountcrc_;
}
inline void relogin::set_uiaccountcrc(::google::protobuf::int32 value) {
  set_has_uiaccountcrc();
  uiaccountcrc_ = value;
  // @@protoc_insertion_point(field_set:mxw.relogin.uiAccountCRC)
}

// optional string szIMEI = 2;
inline bool relogin::has_szimei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void relogin::set_has_szimei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void relogin::clear_has_szimei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void relogin::clear_szimei() {
  if (szimei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_->clear();
  }
  clear_has_szimei();
}
inline const ::std::string& relogin::szimei() const {
  // @@protoc_insertion_point(field_get:mxw.relogin.szIMEI)
  return *szimei_;
}
inline void relogin::set_szimei(const ::std::string& value) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.relogin.szIMEI)
}
inline void relogin::set_szimei(const char* value) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.relogin.szIMEI)
}
inline void relogin::set_szimei(const char* value, size_t size) {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  szimei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.relogin.szIMEI)
}
inline ::std::string* relogin::mutable_szimei() {
  set_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szimei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.relogin.szIMEI)
  return szimei_;
}
inline ::std::string* relogin::release_szimei() {
  clear_has_szimei();
  if (szimei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szimei_;
    szimei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void relogin::set_allocated_szimei(::std::string* szimei) {
  if (szimei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szimei_;
  }
  if (szimei) {
    set_has_szimei();
    szimei_ = szimei;
  } else {
    clear_has_szimei();
    szimei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.relogin.szIMEI)
}

// required .mxw.EClient_OS_Type eClientOSType = 3;
inline bool relogin::has_eclientostype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void relogin::set_has_eclientostype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void relogin::clear_has_eclientostype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void relogin::clear_eclientostype() {
  eclientostype_ = 0;
  clear_has_eclientostype();
}
inline ::mxw::EClient_OS_Type relogin::eclientostype() const {
  // @@protoc_insertion_point(field_get:mxw.relogin.eClientOSType)
  return static_cast< ::mxw::EClient_OS_Type >(eclientostype_);
}
inline void relogin::set_eclientostype(::mxw::EClient_OS_Type value) {
  assert(::mxw::EClient_OS_Type_IsValid(value));
  set_has_eclientostype();
  eclientostype_ = value;
  // @@protoc_insertion_point(field_set:mxw.relogin.eClientOSType)
}

// required uint32 uiServerID = 4;
inline bool relogin::has_uiserverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void relogin::set_has_uiserverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void relogin::clear_has_uiserverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void relogin::clear_uiserverid() {
  uiserverid_ = 0u;
  clear_has_uiserverid();
}
inline ::google::protobuf::uint32 relogin::uiserverid() const {
  // @@protoc_insertion_point(field_get:mxw.relogin.uiServerID)
  return uiserverid_;
}
inline void relogin::set_uiserverid(::google::protobuf::uint32 value) {
  set_has_uiserverid();
  uiserverid_ = value;
  // @@protoc_insertion_point(field_set:mxw.relogin.uiServerID)
}

// required uint32 uiVersion = 5;
inline bool relogin::has_uiversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void relogin::set_has_uiversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void relogin::clear_has_uiversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void relogin::clear_uiversion() {
  uiversion_ = 0u;
  clear_has_uiversion();
}
inline ::google::protobuf::uint32 relogin::uiversion() const {
  // @@protoc_insertion_point(field_get:mxw.relogin.uiVersion)
  return uiversion_;
}
inline void relogin::set_uiversion(::google::protobuf::uint32 value) {
  set_has_uiversion();
  uiversion_ = value;
  // @@protoc_insertion_point(field_set:mxw.relogin.uiVersion)
}

// -------------------------------------------------------------------

// loginRet

// required .mxw.loginRet.ELoginErr nCode = 1;
inline bool loginRet::has_ncode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void loginRet::set_has_ncode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void loginRet::clear_has_ncode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void loginRet::clear_ncode() {
  ncode_ = 1;
  clear_has_ncode();
}
inline ::mxw::loginRet_ELoginErr loginRet::ncode() const {
  // @@protoc_insertion_point(field_get:mxw.loginRet.nCode)
  return static_cast< ::mxw::loginRet_ELoginErr >(ncode_);
}
inline void loginRet::set_ncode(::mxw::loginRet_ELoginErr value) {
  assert(::mxw::loginRet_ELoginErr_IsValid(value));
  set_has_ncode();
  ncode_ = value;
  // @@protoc_insertion_point(field_set:mxw.loginRet.nCode)
}

// required int32 nToken = 2;
inline bool loginRet::has_ntoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void loginRet::set_has_ntoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void loginRet::clear_has_ntoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void loginRet::clear_ntoken() {
  ntoken_ = 0;
  clear_has_ntoken();
}
inline ::google::protobuf::int32 loginRet::ntoken() const {
  // @@protoc_insertion_point(field_get:mxw.loginRet.nToken)
  return ntoken_;
}
inline void loginRet::set_ntoken(::google::protobuf::int32 value) {
  set_has_ntoken();
  ntoken_ = value;
  // @@protoc_insertion_point(field_set:mxw.loginRet.nToken)
}

// -------------------------------------------------------------------

// createRole

// required string szPlayerName = 1;
inline bool createRole::has_szplayername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void createRole::set_has_szplayername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void createRole::clear_has_szplayername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void createRole::clear_szplayername() {
  if (szplayername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szplayername_->clear();
  }
  clear_has_szplayername();
}
inline const ::std::string& createRole::szplayername() const {
  // @@protoc_insertion_point(field_get:mxw.createRole.szPlayerName)
  return *szplayername_;
}
inline void createRole::set_szplayername(const ::std::string& value) {
  set_has_szplayername();
  if (szplayername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szplayername_ = new ::std::string;
  }
  szplayername_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.createRole.szPlayerName)
}
inline void createRole::set_szplayername(const char* value) {
  set_has_szplayername();
  if (szplayername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szplayername_ = new ::std::string;
  }
  szplayername_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.createRole.szPlayerName)
}
inline void createRole::set_szplayername(const char* value, size_t size) {
  set_has_szplayername();
  if (szplayername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szplayername_ = new ::std::string;
  }
  szplayername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.createRole.szPlayerName)
}
inline ::std::string* createRole::mutable_szplayername() {
  set_has_szplayername();
  if (szplayername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szplayername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.createRole.szPlayerName)
  return szplayername_;
}
inline ::std::string* createRole::release_szplayername() {
  clear_has_szplayername();
  if (szplayername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szplayername_;
    szplayername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void createRole::set_allocated_szplayername(::std::string* szplayername) {
  if (szplayername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szplayername_;
  }
  if (szplayername) {
    set_has_szplayername();
    szplayername_ = szplayername;
  } else {
    clear_has_szplayername();
    szplayername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.createRole.szPlayerName)
}

// required int32 nSex = 2;
inline bool createRole::has_nsex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void createRole::set_has_nsex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void createRole::clear_has_nsex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void createRole::clear_nsex() {
  nsex_ = 0;
  clear_has_nsex();
}
inline ::google::protobuf::int32 createRole::nsex() const {
  // @@protoc_insertion_point(field_get:mxw.createRole.nSex)
  return nsex_;
}
inline void createRole::set_nsex(::google::protobuf::int32 value) {
  set_has_nsex();
  nsex_ = value;
  // @@protoc_insertion_point(field_set:mxw.createRole.nSex)
}

// -------------------------------------------------------------------

// createRoleRet

// required int32 nCode = 1;
inline bool createRoleRet::has_ncode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void createRoleRet::set_has_ncode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void createRoleRet::clear_has_ncode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void createRoleRet::clear_ncode() {
  ncode_ = 0;
  clear_has_ncode();
}
inline ::google::protobuf::int32 createRoleRet::ncode() const {
  // @@protoc_insertion_point(field_get:mxw.createRoleRet.nCode)
  return ncode_;
}
inline void createRoleRet::set_ncode(::google::protobuf::int32 value) {
  set_has_ncode();
  ncode_ = value;
  // @@protoc_insertion_point(field_set:mxw.createRoleRet.nCode)
}

// -------------------------------------------------------------------

// playerList_player

// required string szName = 2;
inline bool playerList_player::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void playerList_player::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void playerList_player::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void playerList_player::clear_szname() {
  if (szname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& playerList_player::szname() const {
  // @@protoc_insertion_point(field_get:mxw.playerList.player.szName)
  return *szname_;
}
inline void playerList_player::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.playerList.player.szName)
}
inline void playerList_player::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.playerList.player.szName)
}
inline void playerList_player::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.playerList.player.szName)
}
inline ::std::string* playerList_player::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.playerList.player.szName)
  return szname_;
}
inline ::std::string* playerList_player::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void playerList_player::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.playerList.player.szName)
}

// -------------------------------------------------------------------

// playerList

// required int32 nCount = 1;
inline bool playerList::has_ncount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void playerList::set_has_ncount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void playerList::clear_has_ncount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void playerList::clear_ncount() {
  ncount_ = 0;
  clear_has_ncount();
}
inline ::google::protobuf::int32 playerList::ncount() const {
  // @@protoc_insertion_point(field_get:mxw.playerList.nCount)
  return ncount_;
}
inline void playerList::set_ncount(::google::protobuf::int32 value) {
  set_has_ncount();
  ncount_ = value;
  // @@protoc_insertion_point(field_set:mxw.playerList.nCount)
}

// repeated .mxw.playerList.player players = 2;
inline int playerList::players_size() const {
  return players_.size();
}
inline void playerList::clear_players() {
  players_.Clear();
}
inline const ::mxw::playerList_player& playerList::players(int index) const {
  // @@protoc_insertion_point(field_get:mxw.playerList.players)
  return players_.Get(index);
}
inline ::mxw::playerList_player* playerList::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:mxw.playerList.players)
  return players_.Mutable(index);
}
inline ::mxw::playerList_player* playerList::add_players() {
  // @@protoc_insertion_point(field_add:mxw.playerList.players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mxw::playerList_player >&
playerList::players() const {
  // @@protoc_insertion_point(field_list:mxw.playerList.players)
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::mxw::playerList_player >*
playerList::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:mxw.playerList.players)
  return &players_;
}

// -------------------------------------------------------------------

// selectPlayer

// required string szName = 1;
inline bool selectPlayer::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void selectPlayer::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void selectPlayer::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void selectPlayer::clear_szname() {
  if (szname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& selectPlayer::szname() const {
  // @@protoc_insertion_point(field_get:mxw.selectPlayer.szName)
  return *szname_;
}
inline void selectPlayer::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.selectPlayer.szName)
}
inline void selectPlayer::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.selectPlayer.szName)
}
inline void selectPlayer::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.selectPlayer.szName)
}
inline ::std::string* selectPlayer::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.selectPlayer.szName)
  return szname_;
}
inline ::std::string* selectPlayer::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void selectPlayer::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.selectPlayer.szName)
}

// -------------------------------------------------------------------

// playerBaseData

// required int32 nIdx = 1;
inline bool playerBaseData::has_nidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void playerBaseData::set_has_nidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void playerBaseData::clear_has_nidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void playerBaseData::clear_nidx() {
  nidx_ = 0;
  clear_has_nidx();
}
inline ::google::protobuf::int32 playerBaseData::nidx() const {
  // @@protoc_insertion_point(field_get:mxw.playerBaseData.nIdx)
  return nidx_;
}
inline void playerBaseData::set_nidx(::google::protobuf::int32 value) {
  set_has_nidx();
  nidx_ = value;
  // @@protoc_insertion_point(field_set:mxw.playerBaseData.nIdx)
}

// required string szName = 2;
inline bool playerBaseData::has_szname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void playerBaseData::set_has_szname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void playerBaseData::clear_has_szname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void playerBaseData::clear_szname() {
  if (szname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& playerBaseData::szname() const {
  // @@protoc_insertion_point(field_get:mxw.playerBaseData.szName)
  return *szname_;
}
inline void playerBaseData::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
  // @@protoc_insertion_point(field_set:mxw.playerBaseData.szName)
}
inline void playerBaseData::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mxw.playerBaseData.szName)
}
inline void playerBaseData::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mxw.playerBaseData.szName)
}
inline ::std::string* playerBaseData::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    szname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mxw.playerBaseData.szName)
  return szname_;
}
inline ::std::string* playerBaseData::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void playerBaseData::set_allocated_szname(::std::string* szname) {
  if (szname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete szname_;
  }
  if (szname) {
    set_has_szname();
    szname_ = szname;
  } else {
    clear_has_szname();
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mxw.playerBaseData.szName)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mxw

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mxw::loginRet_ELoginErr> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mxw::loginRet_ELoginErr>() {
  return ::mxw::loginRet_ELoginErr_descriptor();
}
template <> struct is_proto_enum< ::mxw::s2c_PROTOCOL> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mxw::s2c_PROTOCOL>() {
  return ::mxw::s2c_PROTOCOL_descriptor();
}
template <> struct is_proto_enum< ::mxw::c2s_PROTOCOL> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mxw::c2s_PROTOCOL>() {
  return ::mxw::c2s_PROTOCOL_descriptor();
}
template <> struct is_proto_enum< ::mxw::EClient_OS_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mxw::EClient_OS_Type>() {
  return ::mxw::EClient_OS_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
